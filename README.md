Link do Notion com imagens e telas: https://www.notion.so/HACKATHON-QI-TECH-27b69f3ceb3b807e92c7fab1cbbb922f?source=copy_link

## Produto: Venture Debt P2P para SaaS (will.lending)

O serviço em questão se trata de uma plataforma **P2P Crowdlending** especializada em **Financiamento Baseado em Receita (RBF) / Venture Debt**, voltada especificamente para o Growth Capital (capital de crescimento) de empresas _SaaS_ em **Série A ou B**.

## 1. Oportunidade e Posicionamento

Com a ascensão do vibe coding, SaaS de IA se tornou a nova onda. Qualquer um pode transformar um rabisco em um site funcional usando Lovable ou Cursor, com custo praticamente nulo. Todavia, para levar o SaaS a um nível de excelência e escala, é necessário investir: investir em marketing, comunidade, contratações, etc. Para levar um SaaS em seed para graus superiores de maturidade, é necessário usar capital de terceiros. Justamente a fase de **Séries A e B** exige constante injeção de capital de giro para financiar custos de expansão e Aquisição de Clientes (CAC).

O problema central é a **diluição acionária**: Muitos _founders_ e investidores são forçados a vender _equity_ (participação social) caro para financiar custos variáveis previsíveis.

Nesse cenário, alguns buscam empréstimos em bancos tradicionais — e encontram uma porta fechada. O crédito livre para micro e pequenas empresas no Brasil opera a taxas médias de **60% ao ano**, tornando qualquer financiamento de crescimento economicamente inviável quando o ROI de marketing raramente ultrapassa 200-300% em 12 meses. Pior ainda, instituições financeiras tradicionais simplesmente **não entendem o modelo SaaS**: exigem garantias físicas (imóveis, equipamentos, estoque) que empresas digitais não possuem, avaliam risco com base em balanços patrimoniais que ignoram o verdadeiro ativo — a receita recorrente previsível (MRR/ARR) —, e impõem processos burocráticos que levam 45-90 dias para aprovação, um tempo mortal para startups que precisam capitalizar janelas de crescimento em semanas. Para SaaS em Série A/B, cujo valor reside em contratos de assinatura e não em ativos tangíveis, o sistema bancário tradicional é estruturalmente incompatível: um fundador com R$ 200k de MRR crescendo 15% ao mês e NRR de 115% — indicadores que sinalizam saúde excepcional — é tratado como "alto risco" simplesmente por não ter um imóvel para hipotecar. Essa desconexão sistêmica força founders de volta ao único caminho disponível: diluição acionária cara para financiar custos operacionais previsíveis, vendendo participação permanente na empresa para cobrir despesas temporárias de crescimento.

Nossa plataforma resolve essa ineficiência, oferecendo **capital não dilutivo** no momento em que ele é mais crucial, ao mesmo tempo que abre um novo e rentável ativo de dívida para investidores.

## 2. A Solução: Estrutura de Dívida Indexada à Performance (RBF)

Nossa plataforma não oferece um empréstimo tradicional. Ela origina um **Contrato de Mútuo** (dívida) com repagamento flexível, projetado para alinhar o risco ao crescimento da empresa:

### 2.1. Dívida com Juros Indexados à Performance

A remuneração do credor (o que seria o juro) é indexada a uma **porcentagem da Receita Recorrente Mensal (MRR)** do tomador.

- **Proteção ao Fluxo de Caixa:** Em meses de baixo crescimento, a parcela de pagamento cai, protegendo o caixa da _SaaS_ de obrigações fixas.
- **Aceleração:** Em meses de alto crescimento, o pagamento é acelerado, liberando a empresa da dívida mais rapidamente.

### 2.2. Gatilho Anti-_Equity_ (O Múltiplo)

Para garantir a classificação legal como **dívida** e **evitar ser caracterizado como participação acionária (_equity_):**

- **Obrigações Finitas:** O investimento é um mútuo com um **Múltiplo de Pagamento (Cap)** predefinido (Ex: 1.3x o valor emprestado).
- **Teto de Retorno:** O Múltiplo de Pagamento estabelece um teto de retorno final para o investidor. Ao atingir este _cap_, a obrigação da _SaaS_ é encerrada. Isso é o que, legalmente, impede a classificação como _equity_, pois a participação no crescimento futuro da empresa é limitada ao Múltiplo acordado. O investimento é um evento finito.

## 3. Risco e Público-Alvo

A plataforma utiliza uma abordagem conservadora, focada na gestão proativa da inadimplência, para mitigação de risco.

### 3.1. Prevenção e Gestão de Inadimplência: Vigilância Proativa

Utilizamos tecnologia de ponta para resolver o principal problema do P2P: transformar o **Risco de Crédito** em **Risco Operacional Monitorável**.

- **Streaming de Métricas (Visão 360º):** Exigimos acesso via API a três fontes críticas de dados – **Billing** (MRR, NRR), **Usage** (Engajamento do Produto) e **ERP** (Custos/OPEX). Isso permite um cálculo contínuo e auditável do **NRR, LTV:CAC, Burn Multiple e DSCR Ajustado**.
- **Gatilho de Alerta Antecipado (IA/ML):** Nosso motor de Machine Learning prioriza indicadores preditivos, isto é, gatilhos **leading** antes de **lagging**. Prevemos o **Risco de Churn** (a verdadeira Inadimplência no RBF) com semanas de antecedência, acionando _covenants_ proativos (como aumento de relatórios) antes que indicadores _lagging_ (_Default_ _Runway_, _DSCR_, _Burn Multiple_) sinalizem a crise financeira no balanço. A saúde do **ARR** (a garantia da dívida, o ativo subjacente) é o nosso alerta de segurança primário.

### 3.2. Público-Alvo Estratégico

Nossa plataforma é otimizada para a eficiência da captação e para a mitigação de risco regulatório.

- **Tomadores (SaaS Série A/B):** Empresas com modelo de negócios e métricas validados que buscam capital escalável e não dilutivo para financiar crescimento e custos operacionais.
- **Credores (Investidores):** Foco em **Investidores Qualificados**. Este público possui o volume de capital (geralmente acima de R$ 1 mi) necessário para fechar as rodadas de _Venture Debt_ do _SaaS_, cobrindo várias operações. Eles são o perfil ideal para absorver a natureza do ativo RBF, que combina a alta rentabilidade da _Fintech_ com o risco controlado pela garantia do ARR.
- **Evolução da Base de Investidores:**
  1. **Fase inicial** – qualificados, com aportes maiores e menor dispersão.
  2. **Fase intermediária** – criação de veículos estruturados (como títulos de dívida ou fundos lastreados nos contratos originados pela plataforma), permitindo que investidores de varejo participem de forma indireta e regulada.
  3. **Fase futura** – abertura para **varejo direto**, com investimentos acessíveis dentro da própria plataforma, uma vez que houver histórico de performance, marca consolidada e arcabouço regulatório adequado.

## 4. Entidades e Modelo de Dados

O modelo de dados reflete o core do nosso produto: uma plataforma _P2P Crowdlending_ que transforma o Risco de Crédito em Risco Operacional Monitorável através do _streaming_ de dados. A arquitetura é otimizada para a integridade transacional (ACID) e rastreabilidade para auditoria regulatória.

### 4.1. Fluxo de Dados e Eventos

A relação entre entidades tem uma motivação primordialmente procedural (operacional), organizacional e de auditoria.

Temos três principais agrupamentos de lógica:

- **ciclo de vida do investimento**;
- **Controle do escore e inadimplência**;
- \*Contrato e gatilhos.

No tocante à legenda, entidades representam as entidades do _Database_ e o resto representam processos externos ou internos.

- Entidades principais são a base do modelo de negócio;
- Entidades intermediárias registram processamentos intermediários ou dados pré-processamento;
- Entidades secundárias armazenam dados sobre entidades principais, mas que fogem do escopo delas.

![Captura de tela 2025-09-29 005421.png](attachment:e62886b2-fbea-4ae0-a12f-178f139a7f2a:Captura_de_tela_2025-09-29_005421.png)

### I) Ciclo de Vida do Investimento (B)

Em resumo, podemos analisar o investimento linearmente:

- `Investidor` (já cadastrado e aprovado) entra no _Market_, escolhe uma empresa (_SaaS_) e é acrescentado no contrato mútuo, por meio de um `Investimento`.
- O investimento, de vários investidores (_crowdlending_), é passado como crédito (dívida) para o _SaaS_ por meio do `Contrato Mútuo`.
- Mensalmente, o tomador faz o depósito (idealmente de forma automatizada) da parcela, definindo o `Repagamento`.
- Este é computado, ponderado entre os investidores de acordo com o investimento, e então repassado para o investidor, definido o `Repasse Investidor`.
- Por fim, o repasse é depositado na conta do `Investidor`, encerrando o ciclo.

### II) Controle de Escore e Inadimplência (A)

Este flow é responsável por atualizar dinamicamente o escore e guardar informações sobre métricas mensais que influenciarão o contrato (como o MRR, na parcela).

Logo após o onboarding, o Tomador entra com dados estáticos de sua situação contábil e financeira atual (obrigações de divida existentes, receita, caixa, etc.), que será registrado em `Histórico Financeiro` e terá um papel importante para as regras de negócio que influenciarão o escore.

De forma dinâmica, então, o principal fluxo se dá por meio da entrada de dados pelas APIs:

- **Diariamente:** Agregando dados sobre _Usage_ (saúde operacional e engajamento do cliente) e _billing_ (faturamento/cobrança). Serão as principais fontes para projetar a probabilidade de _churn_ e _default_.
- **Mensalmente:** API de sistema contábil. Atualiza a rede sobre como estão progredindo os gastos da empresa, principalmente.

A partir dessas métricas previstas e calculadas, então, atualizamos o escore periodicamente e verificamos se alguma dessas métricas viola algum _covenant_.

### III) Contrato e Gatilhos (Centro)

Inicialmente, o `Contrato Mútuo` é criado pelo `Tomador`. O contrato, então, é atualizado por várias direções:

- **Controle de Inadimplência**: Periodicamente, o motor de ML faz duas verificações: _leading_ (probabilidade de _churn_) e _lagging_ (probabilidade de _default_, _runway_ e _multiple_). Se pelo menos uma dessas três métricas indicar risco, serão acionados os respectivos gatilhos.
- **Gatilhos**: Os gatilhos de _default_, uma vez acionados, atualizarão as _covenants_ (cláusulas ativas) do contrato: o _leading_ aciona medidas preventivas e de atenção, como renegociação ou aumento de logging; o _lagging_ tem um significado mais crítico e pode levar a expansão da dívida ou liquidação imediata do contrato.

### 4.2. Visão Geral (Diagrama)

Haja vista a necessidade de processamento de parcelas e contratos de forma rastreável e auditável, a escolha de um banco de dados relacional (o PostgreSQL) é lógica e natural. Abaixo, um esboço da relação entre entidades em um formato compacto do _schema_ geral:

![Captura de tela 2025-09-28 170142.png](attachment:86367689-9328-4512-8d80-7f8992b2a10b:Captura_de_tela_2025-09-28_170142.png)

Deixando claro que este é um **esboço**. Ele está sujeito a mudança em features pontuais ou eventualmente a adição / reestruturação de uma tabela.

### 4.3. Arquitetura do Banco de Dados

Neste tópico, discutimos sobre o propósito das tabelas e a origem de seus dados, dando destaque relevante para o relacionamento entre elas.

### I) Dados sobre o Usuário (Credor / Devedor)

**Tabela:** **`Investidor`** e **`Tomador`**

- **Origem:** Onboarding (Validação de documentos, Reconhecimento Facial), e APIs de Bureaus de Crédito.
- **Conteúdo:** Dados de Identificação (`CNPJ`, `documento_identificacao`) e Perfis de Risco (`modelo_investimento`, `estagio_investimento`).
- **Motivação:** Estabelecer a **Conformidade Legal (KYC/AML)** e classificar o perfil de risco de ambos os lados para fins de _matching_ e _underwriting_.

**Tabela:** **`DadosBancarios`**

- **Origem:** Informações fornecidas no Onboarding e validação via sistemas PIX/SPB (para o `ispb`).
- **Conteúdo:** Informações de conta (`banco`, `agencia`, `conta`) e o identificador (`ispb`).
- **Motivação:** Garantir o **KYC Operacional** e facilitar o fluxo de dinheiro de aporte e repasse de forma rastreável.

**Tabela:** **`HistoricoFinanceiro`**

- **Origem:** Relatórios submetidos pelo Tomador e verificados contra fontes externas (ERPs, Sistemas Contábeis).
- **Conteúdo:** Demonstrativos Estáticos (`receita_liquida`, `ativo_total`, `patrimonio_liquido`) e Obrigações de Dívida.
- **Motivação:** Servir como a base do **Underwriting inicial**, fornecendo o contexto de longo prazo para a saúde financeira.

**Tabela:** **`ScoringTomador`**

- **Origem:** Output do **Motor de Risco (ML)** e/ou análise manual.
- **Conteúdo:** O **`escore`** calculado, o `tipo` (Inicial/Operacional) e o `metodo` (ML, Regra Fixa).
- **Motivação:** Armazenar o score de risco quantificado do Tomador, rastreando a evolução do risco da _due diligence_ inicial até o monitoramento contínuo.

### II) Dados sobre o Contrato (A Lógica do P2P RBF)

**Tabela:** **`ContratoMutuo`**

- **Origem:** Condições definidas pela plataforma e aprovadas pelo Tomador.
- **Conteúdo:** Termos RBF (**`multiplo_cap`**, **`percentual_mrr`**) e status (`status_funding`, `status_contrato`).
- **Motivação:** **Núcleo do RBF:** Indexar o repagamento à performance e garantir o teto de retorno (**Gatilho Anti-Equity**). O campo `ultima_metrica_mensal_id` liga o Contrato ao seu _snapshot_ de risco mais recente.

**Tabela:** **`Investimento`**

- **Origem:** Aporte de capital dos Investidores aprovados.
- **Conteúdo:** Relação M:N entre `Investidor` e `ContratoMutuo`, incluindo o `valor_aportado` por Credor.
- **Motivação:** Provar a lógica de **P2P Crowdlending**, permitindo que vários credores financiem o mesmo Contrato.

**Tabela:** **`Repagamento`**

- **Origem:** Pagamento de parcela do Tomador.
- **Conteúdo:** `valor_parcela` calculada com base no **`mrr_periodo`** e o progresso em relação ao **`multiplo_atingido`**.
- **Motivação:** Auditar a **natureza flexível** do RBF e rastrear o progresso em direção ao **Cap** (encerramento da dívida).

**Tabela:** **`RepasseInvestidor`**

- **Origem:** Processamento da parcela de `Repagamento`.
- **Conteúdo:** Distribuição individual da parcela paga, separando `principal_devolvido` e `retorno_bruto`.
- **Motivação:** Essencial para fechar o ciclo do P2P, calculando e rastreando a **rentabilidade individual** do Investidor.

**Tabela:** **`CovenantViolado`**

- **Origem:** Disparo de regra ou algoritmo do Motor de Risco (ML) sobre os dados de `MetricaMensal`.
- **Conteúdo:** `tipo_violacao` e `metrica_mensal_id` que identificou a falha do Contrato.
- **Motivação:** Formalizar o evento de estresse de risco, servindo como registro legal que justifica o acionamento de medidas contratuais.

### III) Dados sobre as Métricas

**Tabela:** **`MetricaTempoReal`**

- **Origem:** APIs de **Billing** (MRR, NRR), **Sistemas Contábeis** (OPEX) e **Usage** (Engajamento/Produto).
- **Conteúdo:** Dados brutos de **alta frequência** (`mrr`, `nrr`, `churn_rate`).
- **Motivação:** Servir como o _Data Streaming_ para alimentar o **Modelo ML** com **leading indicators** (o _momentum_ do risco).

**Tabela:** **`MetricaMensal`**

- **Origem:** Agregação e cálculo dos dados do `MetricaTempoReal`.
- **Conteúdo:** Indicadores de estresse **agregados** (`cash_runway_meses`, `dscr_ajustado_mensal`, `net_burn_mensal`).
- **Motivação:** Servir como o _Data Warehouse_ do risco. Fonte estável para **relatórios, dashboards** e ponto de ativação formal dos **Covenants**.

### IV) Auditoria

**Tabela:** **`AuditLog`**

- **Origem:** _Triggers_ ou _hooks_ no Backend API que interceptam alterações nas entidades financeiras.
- **Conteúdo:** `entidade`, `entidade_id`, `acao` (`CREATE`, `UPDATE`, `DELETE`) e o _snapshot_ (`diff`) da mudança.
- **Motivação:** **Requisito de Conformidade Regulatória** que garante a rastreabilidade e a integridade de todas as transações e alterações de status.

## 5. Escore de Crédito e Covenants

### 5.1. Modelo: _Leading_ (ML)

Estes são os "sinais de fumaça". Eles vêm principalmente das APIs de Usage e Billing e alimentam os modelos para prever problemas antes que eles apareçam no balanço contábil.

| Métrica                                | O que Representa                                                                              | Fonte Principal         | Ação (Covenant)                                                                                                      |
| -------------------------------------- | --------------------------------------------------------------------------------------------- | ----------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **Probabilidade de Default (ML)**\*    | O _output_ principal do seu ML. Probabilidade de falha nos próximos 3-6 meses.                | **Motor de Risco (ML)** | **Gatilho de Alerta:** Aumenta a frequência de relatórios exigidos do Tomador ou inicia uma renegociação preventiva. |
| **Queda no Engajamento (WAU/DAU)**\*\* | Redução de usuários ativos diários/semanais (DAU/WAU) ou queda de uso de _features_ críticas. | **API de Usage**        | **Alerta Operacional:** Indica perda de valor do produto, que levará ao _Churn_.                                     |
| **Taxa de _Dunning_**                  | Porcentagem de falhas de pagamento no ciclo de cobrança (antes do _churn_ ser confirmado).    | **API de Billing**      | **Alerta de Cash Flow Imediato:** Indica fragilidade no _cash flow_ do Tomador, mesmo que o dinheiro acabe entrando. |
| **MRR Churn de Clientes Chave**        | _Churn_ ou _downgrade_ de clientes que representam uma alta % do MRR total.                   | **API de Billing**      | **Alerta de Concentração de Risco:** Exige relatório de plano de mitigação de risco de cliente.                      |

### 5.2. Modelo: _Lagging_ (Indicadores Críticos)

Estes são os dados consolidados, fechados no final do mês, que confirmam a eficiência ou ineficiência da empresa. São a base para os Gatilhos de Default Crítico no contrato mútuo.

| Métrica                                | Significado                                                                                                 | Fonte Principal                       | Ação (Covenant)                                                                                                                                                       |
| -------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Runway (Meses)**                     | Projeção mais recente de quantos meses o Tomador tem caixa.                                                 | **MetricaMensal / API de Accounting** | **Gatilho de Default Crítico:** Se menor que _X_ meses, aciona aceleração da dívida.                                                                                  |
| **Burn Multiple**                      | Eficiência do gasto para gerar receita recorrente. Se for alto, indica ineficiência.                        | **MetricaMensal / API de Accounting** | **Gatilho de Default de Eficiência:** Se maior que _X_ por _Y_ trimestres, aciona aumento de juros ou novas condições.                                                |
| **Debt Service Coverage Ratio (DSCR)** | Capacidade da empresa de gerar lucro suficiente para cobrir os pagamentos da dívida. Será projetado por ML. | **Motor de ML**                       | **Gatilho de Default Financeiro:** Se menor que 1.0, a empresa não está gerando caixa para pagar o principal e os juros, e uma liquidação imediata pode ser acionada. |
| **Net Revenue Retention (NRR)**        | Crescimento de receita da base de clientes existente.                                                       | **MetricaMensal / API de Billing**    | **Gatilho de Crescimento:** Se menor que 100% por _Y_ meses (indicando contração da base), pode acionar um alerta ou revisão de termos.                               |

### 5.4. Escore e Regras de Negócio

O _escore_ é o core de uma plataforma P2P, o verdadeiro motor para classificar as _SaaS_ quanto ao risco de ofertar crédito e o retorno por isso.

O escore final é uma função ponderada que combina o motor de ML com métricas periódicas e a estabilidade contratual:

| Componente do Risco                | Fonte                                                           | Peso    |
| ---------------------------------- | --------------------------------------------------------------- | ------- |
| **Risco Preditivo (ML)**           | Probabilidade de Default\*, DSCR                                | **40%** |
| **Risco Estrutural (_Lagging_)**   | Runway, Burn Multiple                                           | **50%** |
| **Risco Estático (KYC/Histórico)** | Histórico de dívidas, Estágio de Investimento (Série A/B), etc. | **10%** |

A componente preditiva (ML) é o insumo secundário para o escore final devido a objetividade de sua métrica para o modelo de negócio em si (a probabilidade de inadimplência), mas sua margem para erros e problemas de interpretação mesmo nos melhores modelos.

A componente de _lagging_ tem a principal relevância por estar fortemente associada ao fluxo de caixa da empresa, e portanto à sua eficiência operacional. É a base de como a performance da empresa reflete o seu futuro naquele _snap_.

A componente de risco estático tem uma componente mínima, mas não desprezível, por guardar características relevantes sobre o _SaaS_ e a empresa em si, mas de carácter estático.

**Não será implementado no escopo deste Hackathon.
** Métrica opcional para o tomador.\*

## 6. Conexão com o Tomador e Motor de Projeções

### 6.1. Formato dos Dados: Tabelas de Métrica e APIs Externas

Após a consulta de alguns empreendedores na área de SaaS, chegamos à conclusão de que SaaS em Série A ou B ainda não possuem necessariamente a maturidade para necessitar de uma API de _feature usage_, frequentemente tendo seus serviços satisfeitos por simples tabelas de logging. Nesse sentido, as **APIs de _Usage_ se tornarão informações opcionais** cuja adição contará positivamente para a avaliação do escore (mais dados, menor o risco inesperado), de modo a não se provar impeditiva para o engajamento no app.

A base, portanto, e que será o MVP deste hackathon, consistirá nas informações provenientes das APIs de _billing_ e de sistemas contábeis. Usaremos o **Stripe Billing** como _PoC_ e mockaremos os dados contábeis, como CAC.

### 6.2. APIs RESTful para o Stripe (endpoints)

Os dados que coletaremos para este MVP serão a base da previsão do MRR futuro: **MRR Histórico**, **Taxa de Dunning**, **LTV**, **NRR** e **Churn Rate**. Para isso, precisamos de alguns dados brutos, detalhados a seguir.

### I) Subscription

Dados de Identificação e Linha do Tempo (LTV, Churn):

| Campo                      | Utilidade e Métrica Relacionada                                                                                                                                                          |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`id`**                   | **Identificador Único.** Essencial para referência em outros objetos (`Event`, `Invoice`) e para rastrear a assinatura ao longo do tempo.                                                |
| **`customer`**             | **ID do Cliente.** **Fundamental para LTV e Churn de Clientes.** Permite agrupar todas as receitas e assinaturas sob um único cliente.                                                   |
| **`created`**              | **Data de Criação.** Usado para calcular o **tempo de vida** do cliente para o **LTV** (junto com a data de cancelamento).                                                               |
| **`status`**               | **Status da Assinatura.** Essencial. Diz se essa receita está **ativa** (MRR base). Se fosse `canceled` (Churn) ou `past_due` (Dunning), seria tratado de forma diferente no seu modelo. |
| **`canceled_at`**          | **Data de Cancelamento.** Se não for `null`, indica a data exata do **Churn** (Receita e Cliente).                                                                                       |
| **`cancel_at_period_end`** | **Churn Agendado.** Se for `true`, indica uma perda de receita futura que deve ser considerada na projeção de **Runway** e **MRR Churn** para o próximo período.                         |
| **`current_period_end`**   | **Fim do Ciclo.** Usado para calcular a data da próxima renovação/fatura. Fundamental para a projeção de **Runway**.                                                                     |
| **`latest_invoice`**       | **Fatura Mais Recente.** Ajuda a cruzar rapidamente com o objeto `Invoice` para fins de **Dunning** e **LTV** (Receita Total).                                                           |

Dados de Valor e Recorrência (MRR e NRR):

| Campo                | Caminho no JSON                                | Utilidade e Métrica Relacionada                                                                                                          |
| -------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| **`unit_amount`**    | `items.data[0].price.unit_amount`              | **Valor da Cobrança.** O valor total em centavos (`1000` centavos = $10.00). **Principal insumo para o MRR.**                            |
| **`currency`**       | `items.data[0].price.currency`                 | **Moeda.** Essencial para a **normalização** em seus relatórios.                                                                         |
| **`interval`**       | `items.data[0].price.recurring.interval`       | **Frequência.** `month` (mensal). Usado para **normalizar o MRR** (dividir o `unit_amount` para a base mensal).                          |
| **`interval_count`** | `items.data[0].price.recurring.interval_count` | **Contagem da Frequência.** `1` (a cada 1 mês). Usado para normalização (ex: se fosse `3` e `interval` fosse `month`, seria trimestral). |
| **`quantity`**       | `items.data[0].quantity`                       | **Quantidade.** O multiplicador do preço. Fundamental para o **MRR Expansão/Contração** por uso ou licença.                              |

Estes campos estão aninhados em `items.data[0].price` (ou `plan`)

### II) Event

### III) Price

### IV) Customer

### V) Invoice

### 6.3. Tendência do DSCR e Runway

### I) Projeção do MRR (Receita)

### II) Projeção do OPEX (Custos)

### III) Os Modelos Finais

## 7. Core Market: Match Investidor-Tomador

O processo de matching opera em quatro fases: (1) Originação da Proposta, (2) Discovery no Marketplace, (3) Pooling de Capital, e (4) Monitoramento Contínuo.

### 7.1. Originação da Proposta (Tomador)

O tomador submete sua solicitação via wizard de 4 steps:

![image.png](attachment:6786d058-b3ea-449d-b4c1-3026b3b59e15:image.png)

**Step 1 - Parametrização:**

- Valor solicitado (limitado pelo score)
- Propósito do capital (marketing, contratações, infraestrutura, etc.)

**Step 2 - Validação de Conectividade (Bloqueante):**

- **Billing (Obrigatório):** OAuth com Stripe/Chargebee para acesso ao MRR, NRR, Churn
  - Sem integração → **fluxo bloqueado**
- **ERP (Recomendado):** Sistema contábil para OPEX e runway
  - Sem integração → penalização de -10 a -15 pontos no score

**Step 3 - Simulação:** Motor de scoring calcula em tempo real:

- Múltiplo (Cap): ex. 1.28x para score 87/100
- Taxa: ex. 4.2% do MRR
- Projeções em 3 cenários (conservador/base/otimista)

**Step 4 - Confirmação:**

- Revisão de termos
- Aceitação de covenants
- Submissão ao marketplace
- Status: `status_funding = 'pendente'` | `status_contrato = 'inativo'`

### 7.2. Discovery no Marketplace (Investidor)

Uma vez aprovado o contrato, ele é submetido ao nosso _Marketplace_ de rodadas de crédito, que é a principal interface de contato entre tomador e investidor.

![image.png](attachment:ba95c4dd-2271-448b-ae23-c8b6f3c1d700:image.png)

O investidor navega na Interface de busca com três mecanismos:

**A) Busca Semântica:**

NLP para queries em linguagem natural (ex: "SaaS B2B NRR >110%")

**B) Filtros:**

- Score (70-100, tiers: 🟢>85, 🟡70-84, 🔴<70)
- Valor (R$10k-500k)
- Stage (Série A/B)
- Setor (SaaS B2B/B2C, E-commerce)
- Status de Funding (<50%, 50-75%, >75%)

**C) Ordenação:**

- Menor risco (score desc)
- Maior retorno (múltiplo × prazo)

**Card de Proposta:**

```
TechSaaS Analytics | Série A | B2B | 🟢 87/100
R$ 150k solicitados | Cap 1.28x | Taxa 4.2%
████████████░░░░ 67% financiado (R$ 100.5k)
MRR: 182k | NRR: 112% | Churn: 2.1%
[Ver Detalhes →]

```

### 7.3. Due Diligence (Investidor)

Página de detalhamento com data room completo:

**Seções:**

**A) Header:** Nome, setor, score, links (site, redes sociais, etc)

**B) Métricas Operacionais:** Gráficos de evolução (12 meses)

- MRR Growth (% m/m)
- NRR Trend
- Churn Rate (voluntário vs involuntário)
- LTV/CAC

**C) Histórico na Plataforma:**

- Contratos anteriores (qtd, valor médio, taxa de atraso)
- Performance de repagamento
- Covenants acionados

### 7.4. Pooling de Capital

**Restrição regulatória:** Máximo R$ 15k por investidor/contrato (SEP).

**Fluxo:**

1. Investidor seleciona valor (R$ 1k - R$ 15k)
2. Pagamento via PIX ou débito de carteira
3. Registro em `Investimento` (M:N)
4. Cálculo de participação: `valor_aportado / valor_total`

**Threshold de Ativação (75%):** Tomador ativa quando pool ≥ 75% do valor solicitado.

**Ao ativar:**

- `status_funding` → `'completo'`
- `status_contrato` → `'ativo'`
- Emissão em blockchain (Seção 8)
- Transferência do capital (24-48h)

### 7.5. Monitoramento Contínuo

### I) Dashboard do Investidor

1. Página “Evolução” :

   - Performance da carteira, Total investido, recebido, TIR média
   - **Gráfico Temporal:** Recebimentos mensais + projeção futura
   - **Tabela de Contratos:** Progresso, valor, empresa, prazo → expandível para tela com métricas aprofundadas e detalhes do contrato.

   ![image.png](attachment:58d78f1a-6204-4906-bd9e-b668fe0c6010:image.png)

2. Página Pagamentos:

   - Gráfico com visualização de histórico de pagamentos e projeções
   - Próximos pagamentos
   - Contratos em detalhes.

   ![image.png](attachment:54e2b66b-3fbc-4689-8268-b80d89fa3e73:image.png)

**Próximos Recebimentos:**

![image.png](attachment:d5a429d3-bf0c-4dee-8344-e13fc997cbc5:image.png)

### II) Dashboard do Tomador

![image.png](attachment:20748f29-afec-4bbe-aab6-36b6c6935e52:image.png)

1. Página “Minhas dívidas”:
   - Propostas em aberto
   - Solicitação de novo empréstimo
   - Acompanhamento dos contratos, progresso, próximos pagamentos
2. Página “Meus Pagamentos”:
   - Cards com próximos pagamentos, projeções para os meses seguintes
   - Histórico de pagamentos
3. Página “Meu score”:
   - Acompanhamento do Score → racional por trás
   - Sugestões para aumentar o seu score.
4. Página “Meu negócio”:
   - Visualização da saúde financeira do SaaS ( MRR, ARR, Churn, CAC, LTV)
   - Previsão de métricas

### 7.6. Fluxo Sistêmico

```
TOMADOR → Solicita → PROPOSTA → MARKETPLACE
                          ↓
                    INVESTIDOR → Descobre
                          ↓
                      POOL → Funding (≥75%)
                          ↓
                    CONTRATO ATIVO
                          ↓
          ┌───────────────┴───────────────┐
     TOMADOR                          INVESTIDOR
    Paga Parcelas                 Recebe Repasses
    Monitora Health              Monitora Portfólio

```

**Métricas-chave:**

- Time-to-Fund: 48-72h (submissão → ativação)
- Fill Rate: % de propostas que atingem 100%
- Default Rate por Score Tier

## 8. Blockchain: Transparência e Automação Por Baixo dos Panos

### 8.1. Blockchain e RBF

### I) Por que blockchain

Revenue Based Funding depende fundamentalmente da confiança entre investidores e tomadores sobre dados de receita reais. Bancos tradicionais falham neste mercado porque não conseguem validar ou auditar MRR de empresas SaaS de forma transparente, criando assimetria de informação que resulta em rejeição de 80% dos pedidos de crédito. Blockchain resolve este problema criando um registro imutável e auditável de todas as transações financeiras, eliminando disputas sobre valores pagos e recebidos.

- **Transparência auditável**: Todos os pagamentos mensais baseados em MRR ficam registrados publicamente, eliminando disputas sobre valores
- **Automação de pagamentos**: Smart contracts executam repasses automaticamente quando oráculos atualizam MRR, sem intervenção manual
- **Fracionamento transparente**: Investidores veem exatamente sua participação e recebimentos proporcionais em tempo real
- **Compliance**: Registro imutável facilita auditoria para Banco Central e investidores

### II) Como usaremos blockchain (Abstraction e Login social)

A maior barreira para adoção de blockchain em finanças é a complexidade técnica que afasta 95% dos usuários potenciais. Nossa estratégia é tornar blockchain completamente invisível através de Account Abstraction, permitindo que usuários interajam com contratos inteligentes através de interfaces familiares como login social e transações em reais. Esta abordagem democratiza acesso a tecnologia avançada sem exigir conhecimento técnico.

- **Account Abstraction (EIP-4337)**: Usuários fazem login com Google/email, sistema cria carteira invisível automaticamente
- **Gasless transactions**: Plataforma paga gas fees, cobra taxa em reais via PIX posteriormente
- **Web3Auth**: Gerencia identidade social → carteira mapping, permite recuperação por email
- **Meta-transactions**: Usuários assinam intenções, relayer executa transações na blockchain

### III) Integração Blockchain e RBF: ChainLink e Oráculos

RBF precisa de métricas de receita em tempo real para calcular pagamentos variáveis mensais, mas smart contracts não conseguem acessar APIs externas nativamente devido ao problema do oracle. Para integrar blockchain com dados externos de billing (ChartMogul, Stripe), usaremos oráculos descentralizados como Chainlink, que permitem validação confiável de dados off-chain e automação completa do ciclo de pagamentos baseado na performance real das empresas.

- **Chainlink Functions**: Executa código customizado mensal que consulta API de billing da empresa (ChartMogul, Stripe)
- **Oracle node dedicado**: Valida MRR através de múltiplas fontes, submete dados para smart contracts
- **Pagamento automático**: Quando oracle atualiza MRR, smart contract calcula e distribui pagamentos proporcionalmente
- **Dados auditáveis**: Histórico de MRR fica on-chain, investidores verificam saúde da empresa independentemente

### 8.2. O que será feito

### I) Fluxos principais

O sistema completo requer três fluxos fundamentais que cobrem todo o ciclo de vida do investimento RBF. Primeiro, precisamos abstrair a complexidade de criar carteiras blockchain para usuários tradicionais. Segundo, devemos gerenciar o processo de funding colaborativo até ativação do contrato inteligente. Terceiro, automatizar completamente a distribuição de pagamentos baseada em dados reais de receita, eliminando intermediários e garantindo transparência total.

Seus 3 fluxos estão **corretos** e cobrem todo o ciclo:

**1. Fluxo de criação de carteira**

- Login social (Google/email) → Web3Auth cria carteira invisível
- KYC tradicional + binding carteira blockchain ao usuário
- Zero conhecimento técnico necessário

**2. Fluxo de transação → ativação do contrato**

- Factory Contract: escrow off-chain até atingir threshold (75%)
- Deploy automático: cria contrato RBF individual quando funding completo
- Transferência atômica: fundos escrow → contrato ativo

**3. Fluxo de repasse para investidores**

- Oracle atualiza MRR mensalmente
- Smart contract calcula pagamento (MRR × percentual acordado)
- Distribuição automática proporcional para todos os investidores

### II) Escopo hackathon → demonstrar esses fluxos

Um hackathon exige demonstração tangível de valor em tempo limitado, focando na prova de conceito dos fluxos mais impactantes. Nosso MVP em 48 horas demonstrará todos os três fluxos principais com dados simulados mas realísticos, permitindo que juízes vejam a solução funcionando end-to-end. A demonstração precisa ser visual, interativa e mostrar claramente o diferencial competitivo da transparência blockchain.

**MVP em 48h**: Demonstrar os 3 fluxos completos com dados mockados

- **Fluxo 1**: Login com Google, carteira criada automaticamente
- **Fluxo 2**: Investimento em pool, deploy quando 100% atingido, transação visível no Etherscan
- **Fluxo 3**: Simulação de pagamento mensal com Oracle mockado, distribuição para investidores

**Demo script**: 5 minutos mostrando empresa SaaS solicitando crédito → investidores investindo → contrato deployado → pagamento automático executado

### 8.3. Como será feito?

### I) Stack que será usada e por que

A escolha do stack tecnológico balança velocidade de desenvolvimento para hackathon com robustez necessária para escalabilidade futura. Priorizamos ferramentas maduras com boa documentação e integração TypeScript nativa, permitindo que a equipe implemente rapidamente sem sacrificar qualidade técnica. Polygon oferece transações rápidas e baratas essenciais para boa UX, enquanto Web3Auth simplifica drasticamente a experiência de onboarding.

**Blockchain:**

- **Solidity 0.8.19**: Smart contracts (Factory + RBF individual)
- **Hardhat**: Development framework, testing, deployment
- **OpenZeppelin**: Bibliotecas seguras (Ownable, ReentrancyGuard)
- **Polygon Mumbai**: Testnet para hackathon (transações rápidas, gratuitas)

**Account Abstraction:**

- **Web3Auth SFA**: Social login → carteira mapping
- **Biconomy SDK**: Gasless transactions, meta-transactions
- **Ethers.js v6**: Interação Web3 (mais leve que Web3.js)

**Oracle Integration:**

- **Chainlink Functions** (hackathon): Oracle simulado para MRR
- **Custom API**: Mock ChartMogul/Stripe responses
- **Cron job**: Simula updates mensais em intervalo acelerado (30s)

### II) Conexão com o restante do projeto (TypeScript)

A integração blockchain deve ser transparente para o restante da aplicação TypeScript, exposta através de interfaces bem definidas que abstraem complexidade Web3. Esta arquitetura permite que desenvolvedores frontend trabalhem com objetos JavaScript familiares enquanto toda a lógica blockchain fica encapsulada em serviços especializados. Real-time updates via WebSocket garantem que dashboards reflitam mudanças de estado blockchain instantaneamente.

**Integração com backend TypeScript:**

```tsx
typescript*// types/blockchain.ts*
export interface RBFContract {
  address: string;
  company: string;
  totalAmount: bigint;
  currentMRR: bigint;
  investors: InvestorShare[];
}

*// services/blockchain.service.ts*
export class BlockchainService {
  async createCreditRequest(params: CreditParams): Promise<string>
  async investInCredit(creditId: string, amount: bigint): Promise<void>
  async getContractStatus(address: string): Promise<RBFContract>
}

*// hooks/useBlockchain.ts - React hooks para frontend*
export const useRBFContract = (address: string) => {
  const [contract, setContract] = useState<RBFContract>();
  *// WebSocket para updates em tempo real*
}

```

**Arquitetura de serviços:**

- **blockchain.service.ts**: Abstrai toda interação Web3
- **oracle.service.ts**: Simula dados MRR e trigger pagamentos
- **wallet.service.ts**: Gerencia Web3Auth e Account Abstraction
- **notification.service.ts**: WebSocket para updates em tempo real

**Pipeline de dados:**

1. Frontend TypeScript → blockchain.service.ts
2. blockchain.service.ts → Ethers.js → Smart Contract
3. Oracle service → Smart Contract → Webhook → Frontend update
4. Real-time dashboard via WebSocket para mostrar transações live

**Demonstração técnica**: Console browser mostrando logs de transações, Etherscan links para verificação, dashboard atualizando automaticamente quando Oracle trigger pagamentos.

## 9. Arquitetura Técnica e Deploy

### 9.1. Frontend

- _Linguagem_: Typescript
- _Framework_: React

A escolha de **Typescript** com **React** para o _frontend_ é a combinação ideal para aplicações complexas, garantindo escalabilidade e manutenção a longo prazo. O Typescript adiciona tipagem estática, que é crucial para minimizar erros em uma aplicação financeira onde a precisão é vital, enquanto o React oferece uma biblioteca robusta para construir interfaces de usuário dinâmicas (como dashboards de risco e painéis de investimento).

### 9.2. Backend (core app)

- _Linguagem_: Typescript
- _Framework_: Next.js

A decisão por TypeScript foi pela tipagem nativa. Com dados tipados, garantimos segurança e estabilidade, essenciais para um serviço financeiro robusto. Além disso, ao usar TypeScript no backend, nós

### 9.3. Backend (Python - ML)

- _Linguagem_: Python
- _Arquitetura_: Notebooks, Pipelines e Makefile

A decisão de isolar a lógica de Machine Learning em **Python** é praticamente obrigatória, pois esta é a língua franca da ciência de dados, oferecendo o ecossistema mais rico de bibliotecas para modelos preditivos e processamento de dados. A arquitetura de **Notebooks** e **Pipelines** é ideal para o projeto: _Notebooks_ para pesquisa e desenvolvimento dos modelos de _scoring_ (Probabilidade de Default, Projeção do DSCR), e Pipelines (automatizados por Makefile) para produção, garantindo que o seu motor de risco seja treinado, versionado e executado de forma consistente e auditável.
